# 데이터 중심 어플리케이션 설계

## 07. 트랜잭션
### 트랜잭션이 보장하는 안전성 보장
#### 원자성, 일관성, 격리성, 지속성(ACID)

- 원자성
하나의 원자적 작업으로 묶여있을 때, 결함때문에 커밋될 수 없다면, 어보트되고 DB는 이 트랜잭션에서 일어난 쓰기를 무시, 취소한다.
- 일관성
일관성을 유지하도록 트랜잭션을 올바로 정의하는 것은, 애플리케이션의 책임이다.
- 격리성
동일한 데이터베이스 레코드에 접근하면 동시성 문제가 발생한다.
동시에 실행되는 트랜잭션은 격리된다. cf. 직렬성 격리, 스냅숏 격리
- 지속성
트랜잭션이 성공적으로 커밋되었다면, 트랜잭션에서 기록한 데이터는 손실되지 않는다.

### 단일 객체 연산, 다중 객체 연산
격리성은 변화된 것을 모두 보거나, 모두 보지 못하게 하고 일관성이 깨진 중간은 보지 못하도록 해준다.
다중 객체 트랜잭션은 어떤 읽기, 쓰기 연산이 동일한 트랜잭에 속하는지 알아낼 수단이 있어야 한다.(ex. client-db 간의 tcp 연결, transaction begin ~ commit)

저장소 엔진은 단일 객체 수준에서 원자성, 격리성을 제공하는 것을 목표로 한다.
원자성은 장애 복구용 로그를 써서 구현 가능. 격리성은 각 객체에 잠금 사용해서 구현 가능하다.
 *갱신손실

### 완화된 격리수준
직렬성 격리 : 데이터 베이스가 여러 트랜잭션들이 직렬적으로 실행되는 것 (한번에 한개)을 보장하는 것을 말한다.
동시성 문제의 종류들을 잘 이해하고, 방지하는 방법을 배울 필요가 있다.

#### 커밋 후 읽기
- 가장 기본적인 수준의 트랜잭션 격리
1. 더티 읽기가 없다.
2. 더티 쓰기가 없다.

#### 스냅숏 격리 구현
더티 쓰기 방지를 위해 쓰기 잠금을 사용한다. 하지만 읽을 때는 아무 잠금도 필요 없다.
핵심원리 : 쓰는 쪽 <-> 읽는 쪽 서로 차단하지 않는다.
데이터는 객체마다 커밋된 버전 여러개를 유지할 수 있어야 한다. 진행 중인 여러 트랜잭션에서 서로 다른 시점의 데이터 베이스 상태를 봐야하기 때문.
: 다중 버전 동시성 제어라고도 한다.

##### 일관된 스냅숏을 보는 가시성 규칙
##### 색인, 스냅숏 격리