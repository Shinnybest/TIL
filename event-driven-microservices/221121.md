## Why Event-Driven Microservices?
이벤트 스트리밍 방식의 데이터 통신 구조에서는 데이터를 소유/생산하는 것과 데이터에 접근하는 행위가 철저히 분리된다.
그래서 서비스는 더이상 직접 요청 - 응답 API 에 얽매이지 않고 이벤트 스트림 내부에 정의된 이벤트 데이터를 매개로 소통한다.

Point 1. 이벤트로 통신한다. 즉 이벤트가 곧 데이터이다.
Point 2. 이벤트는 데이터를 실어나르는 수단이 아니라, 데이터 스토리지이자 서비스 간의 비동기 통신 수단 역할을 한다.
Point 3. 이벤트 스트림은 단일 진실 공급원이다. 이벤트 스트림에 들어갔다는 것 자체는, 이미 정보가 정확하다는 증거이다.
Point 4. 컨슈머가 스스로 모델링과 쿼리를 수행한다. 프로듀서, 컨슈머 모두 쿼리 매커니즘을 제공하는 것이 아니라 각자 컨텍스트의 니즈만 해결하면 된다.

서비스의 종류
- 상태 비저장 서비스
- 상태 저장 서비스
- 동기식 요청-응답 API가 포함된 서비스
이벤트 기반 마이크로서비스는 이벤트 브로커에서 이벤트를 생산/소비하는 공통 기능을 공유하며 완전한 비동기 방식으로 통신한다.

토폴로지
- 마이크로서비스 토폴로지 : 
- 비즈니스 토폴로지 : 

## 이벤트 기반 마이크로서비스의 기초

### 이벤트 콘텐츠
이벤트 : 비즈니스 통신 구조에서 발생한 무엇이라도 가능, 발생한 사건의 기록물

#### 이벤트 구조 : 
- 키없는 이벤트 : 하나의 사실을 진술한 형태
- 엔티티 이벤트 : 연속된 이력을 제공, 상태를 구체화하는 용도로 사용가능, 엔티티의 현재 상태는 마지막 엔티티 이벤트만 봐도 알 수 있어 중요하다
- 키있는 이벤트 : 

테이블-스트림 이원성이라는 특정 때문에, 이벤트 기반 마이크로서비스 간의 상태 전달에 활용된다.
이 강력한 패턴은 프로듀서 - 컨슈머가 직접 결합하지 않아도 상태를 공유할 수 있게 된다.

컴팩션을 수행하면 이벤트 스트림에 쌓인 이벤트 이력은 포기해야 하지만 디스크 사용량이 줄고 이벤트 수도 감소하기 때문에 이점이 있다. 해당 작업은
상류(업스트림) 프로듀서가 하고, 다운스트림 컨슈머에게 알려주는 것이 일종의 관례이다.

프로듀서-컨슈머는 데이터의 의미를 똑같이 이해하는 것이 중요하다. 그래서 아파치 아브로, 구글 프로토콜 버퍼 같은 스키마화 기술이 있다.
- 다운스트림 컨슈머가 코드를 변경하지 않아도 스키마 변경을 안전하게 처리할 수 있다.
- 스키마화 데이터를 특정 언어의 일반 객체로 변환할 때 필요한 정형 클래스를 생성한다.

이벤트 스트림은 말그대로 물 같다. 제일 첫번째 근원이 있다는 것이다. 즉 정확히 하나의 생산 마이크로 서비스 즉 이벤트의 진실 공급원을 가진다.

마이크로서비스는 이벤트 브로커로 강화된다.

### 이벤트 브로커의 특징
- 확장성 : 이벤트 브로커의 인스턴스 추가하면, 클러스터의 생산/소비 용량 늘릴 수 있다.
- 보존성 : 노드간 이벤트 데이터가 복제되어서 한개 장애가 나도, 괜찮을 수 있다.(3개 이상의 브로커 필요?)
- 고가용성 : 장애 발생해도 클라이언트는 다른 브로커에 접속할 수 있다.
- 고성능

#### 이벤트 보관 및 처리
하부 데이터 스토리지의 최소요건
- 파티셔닝 : 이벤트 스트림을 파티셔닝하면, 여러 컨슈머 인스턴스가 하위 스트림을 병렬 처리하면서 처리량 높일 수 있다.
- 순서 보장
- 불변성 : 발행되면 수정 불가능
- 인덱싱 : 이벤트 스트림에 발행되는 시점에 인덱스(오프셋)이 할당됨
- 무기한 보존 : 이벤트 무기한 보존 가능
- 재연성 : 어떤 컨슈머라도 데이터 가져가서 읽을 수 있다.

이벤트 기반 마이크로서비스 구축할 때 아래의 사항들은 구현체를 따르는데 잘 고민해보고 기술을 선택해야 겠다.
- 이벤트, 스키마 데이터 조회
- 쿼터, 접근 제어, 토픽 관리
- 모니터링, 처리량, 컨슈머 랙 측정
- 장기 계층형 스토리지 -> 이벤트 브로커나 그 노드에는 최고 성능 계층에 해당하는 전용 로컬 디스크를 붙이고 나머지는 저렴한 스토리지에 저장

### 이벤트 브로커 vs 메시지 브로커
메세지 브로커 : 메세지가 소비된 것으로 ACK 되면 즉시, 짧은 시간 내에 삭제됨
이벤트 브로커 : 순서대로 쌓은 사실 로그를 제공할 목적으로 설계(각 컨슈머가 이벤트 마음대로 꺼내갈 수 있다. 이벤트 보존 오랫동안 가능하다.)